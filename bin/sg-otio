#!/usr/bin/env python
import argparse

import opentimelineio as otio
from shotgun_api3 import Shotgun
from six.moves.urllib import parse

from sg_otio.sg_settings import SGSettings


def run():
    """
    Parse command line arguments and read/write cuts from/to SG from/to OTIO.
    """
    parser = argparse.ArgumentParser(description="Read Cuts from SG to OTIO format, or write OTIO files to SG as Cuts.")
    subparser = parser.add_subparsers(dest="command")
    # Read sub parser
    read_parser = subparser.add_parser(
        "read",
        help="Read a Cut from SG and write it to a OTIO Timeline."
    )
    # Write sub parser
    write_parser = subparser.add_parser(
        "write",
        help="Write a OTIO Timeline to SG as a Cut."
    )
    # Common arguments for read and write.
    # We need to add them to the subparsers and not the main parser so that
    # the first positional argument is "read" or "write".
    add_common_args(read_parser)
    add_common_args(write_parser)
    # Read parameters
    read_parser.add_argument(
        "--cut-id", "-i",
        required=True,
        help="The ID of the SG Cut to read."
    )
    read_parser.add_argument(
        "--file", "-f",
        required=False,
        help="An optional output file to write the OTIO Timeline to. If not provided, the output is printed to stdout."
    )
    # Write parameters
    write_parser.add_argument(
        "--file", "-f",
        required=True,
        help="The OTIO file to read the Timeline from."
    )
    write_parser.add_argument(
        "--adapter", "-a",
        required=False,
        help="The adapter to use to read the OTIO file. If not provided, the default adapter"
             "given the extension is used."
    )
    write_parser.add_argument(
        "--entity-type", "-e",
        required=True,
        help="The SG Entity type to link the Cut to. It can be a Project, a Cut, or any Entity that can be linked to "
             "a Cut, e.g. a Sequence, a Reel."
    )
    write_parser.add_argument(
        "--entity-id", "-i",
        required=True,
        type=int,
        help="The SG Entity id to link the Cut to."
    )
    write_parser.add_argument(
        "--settings", "-s",
        required=False,
        help="The settings JSON file to use when writing the Cut. If not provided, the default settings are used."
    )

    args = parser.parse_args()

    # Check that we can login to SG
    if not (args.login and args.password):
        if not (args.script and args.api_key):
            if not args.session_token:
                raise ValueError(
                    "You must provide either a login, password, script name and API key or a session token."
                )

    if args.command == "read":
        read_from_sg(args)
    elif args.command == "write":
        write_to_sg(args)


def read_from_sg(args):
    """
    Reads information from a Cut in ShotGrid and returns a
    :class:`otio.schema.Timeline` instance.

    It can either print it to stdout or write it to a file.

    The retrieved SG entities are stored in the items metadata.

    :param args: The command line arguments.
    """
    url = _get_read_url(args)
    timeline = otio.adapters.read_from_file(
        url,
        adapter_name="ShotGrid",
    )
    if not args.file:
        print(otio.adapters.write_to_string(timeline))
    else:
        otio.adapters.write_to_file(timeline, args.file)


def write_to_sg(args):
    """
    Write an OTIO file to SG as a Cut.

    :param args: The command line arguments.
    """
    url = _get_write_url(args)
    timeline = otio.adapters.read_from_file(
        args.file, adapter_name=args.adapter
    )
    if args.settings:
        SGSettings.from_file(args.settings)
    otio.adapters.write_to_file(timeline, url, adapter_name="ShotGrid")
    print("File %s successfully written to %s" % (args.file, url))

def add_common_args(parser):
    """
    Add common arguments for reading and writing from/to SG.

    :param parser: An instance of :class:`argparse.ArgumentParser`.
    """
    # Common arguments to read and write
    parser.add_argument(
        "--url", "-u",
        required=True,
        help="The SG URL to read the Cut from."
    )
    # Read login parameters
    # Option 1: login + password
    parser.add_argument(
        "--login", "-l",
        required=False,
        help="The SG login to use to login."
    )
    parser.add_argument(
        "--password", "-p",
        required=False,
        help="The SG password to use to login."
    )
    # Option 2: script name and API key
    parser.add_argument(
        "--script-name", "-sn",
        required=False,
        help="The SG script name to use to login."
    )
    parser.add_argument(
        "--api-key", "-k",
        required=False,
        help="The SG API key to use to login."
    )
    # Option 3: session token
    parser.add_argument(
        "--session-token", "-t",
        required=False,
        help="The SG session token to use to login."
    )


def _get_write_url(args):
    """
    Get the URL to write a Cut to SG from the arguments.

    :param args: The command line arguments.
    """
    session_token = _get_session_token(args)
    # Construct the URL with urlparse
    parsed_url = parse.urlparse(args.url)
    query = "session_token=%s&id=%s" % (
        session_token,
        args.entity_id,
    )
    # If no scheme was provided, netloc is empty and the whole url is in the path.
    # So we just append Cut to it.
    path = "%s/%s" % (parsed_url.path, args.entity_type)
    # Make sure to add https:// if the url was provided without it.
    return parsed_url._replace(
        scheme="https", query=query, path=path
    ).geturl()


def _get_read_url(args):
    """
    Get the URL to read a Cut from SG from the arguments.

    :param args: The command line arguments.
    """
    session_token = _get_session_token(args)
    # Construct the URL with urlparse
    parsed_url = parse.urlparse(args.url)
    query = "session_token=%s&id=%s" % (
        session_token,
        args.cut_id
    )
    # If no scheme was provided, netloc is empty and the whole url is in the path.
    # So we just append Cut to it.
    path = "%s/Cut" % parsed_url.path
    # Make sure to add https:// if the url was provided without it.
    return parsed_url._replace(
        scheme="https", query=query, path=path
    ).geturl()


def _get_session_token(args):
    """
    Get the session token from the arguments.

    :param args: The command line arguments.
    """
    if args.session_token:
        return args.session_token
    if args.login and args.password:
        sg = Shotgun(args.url, login=args.login, password=args.password)
    elif args.script_name and args.api_key:
        sg = Shotgun(args.url, script_name=args.script_name, api_key=args.api_key)
    return sg.get_session_token()


if __name__ == "__main__":
    run()
